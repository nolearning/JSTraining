十分钟学会JavaScript
====================
###作者Spencer Tipping###
1	简介
------------------
本指南适用于任何知道一些Javascript，并想快速[1]了解其先进功能的读者。如果你还了解另一种函数式语言，如Ruby，Perl，Python或ML，Scheme等，它会更容易阅读，因为我没有解释初级的函数原理。 
>1.会超过10分钟，尽管标题这么写。

2	类型
------------------
JavaScript有九种类型。分别为：

1.空值类型（null）- 它没有任何属性。例如：null.foo 无效。类型unboxed[1]。
2.未定义（undefined）- 访问未创建对象的返回。例如：document.nonexistent。也没有任何属性，类型unboxed。
3.字符串（string） - 例如：'foo'，“foo”（单、双引号没有区别）。某些时候类型boxed，例如作为字符串实例时。
4.数值（Numbers） - 例如：5， 3E+10（在除法运算时所有的数字以浮点方式处理，但可以通过X >>> 0方式截断）。某些时候类型boxed，例如数字实例时。
5.布尔（bool） - true或者false。某些时候类型boxed，例如布尔实例时。
6.数组（Array） - 例如： [1，2，“foo”，[3，4] |。类型boxed，数组实例。
7.对象（Objects） - 例如：哈希表{foo：'bar'，bif：[1，2]}。类型boxed，对象实例。
8.正则表达式（RegularExpression） - 例如： / foo \ s*（[bar] +）/。类型boxed，RegExp实例。
9.函数（Functions）- 例如：function(x) {return x + 1}。类型boxed，函数实例。
实际上空值几乎是从来不会通过Javascript产生的。只有一种情况，你可能会碰到空值，如果你指定的地方（大部分时间，你会得到未定义，一个值得注意的例外是document.getElementById，如果找不到对应元素它返回NULL）。一般情况下，建议使用未定义类型， 而不是使用空类型，这样可以使错误更容易追查。

>1.Boxing是指的其是否由指针表示。boxed类型是一个引用类型，unboxed类型是一个值类型。在JavaScript中，这会有额外的影响，可参见4.6节。

3	函数（Functions）
-----------------------------
  功能是一流的词法闭包 ， | |分|拉姆达在Ruby或。在Perl 它们的行为很像你所期望的，但也有一些很酷的功能的东西和。一个真正令人震惊的灾难。

###3.1	可变参数的行为（一件很酷的事情）###
功能总是可变 ，是可变正式参数绑定，如果他们存在;否则他们未定义。
例如：
//code

（函数（X，Y）{返回x + Y}）（'富'）/ / =>'fooundefined“


    一流的方式，也可以访问到你的函数的参数：


VAR f =函数（）{返回参数[0 +参数[1]};
G =（）{返回的arguments.length};
F（'富'）/ / => fooundefined的“
Ğ（空的，假的，不确定的）/ / => 3


    {\，{\ TT参数}关键字是不是一个数组！它看起来就像一个。特别是，做任何这些会引起问题：


arguments.concat（[1，2，3]）
[1，2，3]。Concat的（论据）
arguments.push（'富'）
arguments.shift（）


    |参数|对象数组，以获得从，你可以说| Array.prototype.slice.call（参数）。据我所知，这是最好的方式去它。

###3.2	\第{懒惰的范围（一件很酷的事情）}###
    在内部，功能使用词法作用域链。然而，在函数体内的变量都没有解决，直到函数被调用。这有一些非常好的优势，
    也许其中最重要的自我参考：


VAR F =（）{返回f};
F（）=== F / / =>真


    \开始{引用}
      {\ BF珍闻病理：}懒作用域的重要后果是，你可以创建功能，是指可能永远存在的变量。这使得使用Javascript很难
      调试。良好的部分是，JavaScript可以支持通过句法宏|的toString |方法：


VAR F =（）{$ 0 $ 1};
VAR G =的eval（f.toString（）（/ \ $（\ D +）/克，
          功能（，数字）{'参数['+数字+']'}））;
G（5,6）/ / => 11（在IE浏览器除外）


      理论上延长这一原则，人们可以实现真正的结构宏，运算符重载，类型系统，\脚注{上帝保佑。}或其他东西。
    \ {引用}

###3.3 this的含义（令人震惊的灾难）###
this是什么？这个问题看起来很简单，但实际上相当具有挑战性，而JavaScript使它成为近乎不可能回答清楚。当位于函数外（即全局域），this指向特定的全局对象，在浏览器环境中是window对象。本质的问题是在函数内部this会有什么的行为，而这会取决于函数本身的调用方式。具体如下：

1.如果该函数被直接调用，如foo(5)，那么该函数的内部的this将指向全局对象。
2.如果该函数作为对象的方法被调用，如x.foo（5），那么该函数内部的this指向该对象，例子中为对象X。
3.如果该函数开始为对象的方法，然后被直接调用：
    var f = x.foo;
    f(5);
那么this重新指向全局函数。调用方式决定this的指向，f的赋值方式并不会对此产生影响。
4.如果该函数调用使用apply或call，此时this指向所设置的对象（除非尝试将其设置为null或undefined，此种情况this将重新指向全局函数):
    var f = function() { return this; };
    f.call(4)       // => 4
    f.call(0)       // => 0
    f.call(false)   // => false
    f.call(null)    // => [全局对象(object global)]
鉴于此种不可预知性，很多JavaScript库提供了方法来设置函数this绑定至某调用不变量（在JavaScript圈子中称为函数绑定）。一个极简方案是定义一个函数利用apply传递参数和正确this值（幸运的是，闭包变量行为正常）：
    var bind = function(f, this_value) {
        return function() { return f.apply(this_value, arguments); };
    };
apply和call之间的区别很简单：f.call(x, y, z)等同于f.apply(x, [y, z])，这与bind(f, x)(y, z)是一样的。也就是说，call和apply的第一个参数会作为函数的this所指向的对象，其余则作为参数传递给函数。在apply中传递的参数集合应在一个数组中，而call中则直接将给定的参数转发（第一个参数除外）。

####3.3.1 重要的后果：ETA减少}####
中功能最全的编程语言，你可以埃塔减少的事情，也就是说，如果你有一个函数的形式|函数（x）{F（X）} |，你可以使用| F |，而不是返回。 但在Javascript这并不总是一个安全的转变;考虑下面的代码：
    array.prototype.each =功能（F）{
        （VAR我= 0，L = this.length; <L + + I）
        F（[I]）;
    };
    
    XS = [];
    some_array.each（函数（x）{xs.push（X）}）;
这可能是诱人的更为简洁的改写：
    some_array.each（xs.push）;
会，但后者的形式将在一个神秘的Javascript错误导致当本机| Array.push函数找到|这是全局对象，而不是| XS。 原因应该是显而易见的：|每| 内部称为函数时，它被调用的功能，而不是一个方法。事实上，功能开始作为一种方法      | XS被遗忘。 （就像\ REF {ITM：忘记}。以上）围绕这个最简单的方法是结合| xs.push |以| XS |：
    some_array.each（绑定（xs.push，XS），）;

####3.3.2	从来都不是falsy {奇珍闻：{\ TT这}}####
原因在部分解释\ REF {秒：拳击} {\ TT这将永远不会被设置到falsy值。如果您尝试将其设置为{\ TT空}或{\ TT未定义}，这样说：
    VAR =函数（）{
        返回本;
    };
    f.call（空）; / /返回空，对吗？

会事实上，它会成为全球的{\ TT这个}，通常在浏览器{\ TT视窗中}。如果您使用falsy原始，{\ TT这}将参考的，原始的盒装版本。这有一些有悖常理的后果，更详细地覆盖在第\ REF {秒：自动装箱}。

4	Gotchas
------------------------
JavaScript是一种语言像Perl的真棒，是一个可怕的语言和Linux是一个可怕的操作系统。如果你知道如何正确地使用它，它会解决您的所有问题平凡（好，几乎），如果你错过了它的奥妙之一，你会花几个小时追捕错误。我已经收集到的事情，我已经运行到这里，其中应包括JavaScript的
  语言病理学[1]。
>1.有大量的这种病虽然JavaScript作为一般一个优秀的语言。这使得它理想的人谁不想把事情做好，像我这样的错误鉴赏家。

###4.1	分号推断###
你不会碰上任何麻烦，如果你总是用分号结束线。然而，大多数浏览器认为它是可选的，有一个潜在的惊喜潜伏的，如果你选择省略他们。
大部分时间的Javascript请问你是什么意思。唯一的情况下，它可能不会是当您启动线，这样一个开放的括号：
    VAR X = F
    （Y = X）（5）
JavaScript加入这两行，形成：
    VAR X = F（Y = X）（5）
在解决这个问题的唯一途径，我知道是放在第一行末尾的分号。

###4.2	void函数###
每一个函数返回一个值。如果你不使用|返回|声明，那么你的函数返回|未定义|;否则返回不管你告诉它。这可以是一个共同的源使用Ruby或者Lisp的人的错误，例如，
    VAR =（函数（Y）{Y + 1}）（5）;
会结果| X | |未定义|。如果你有可能使这一滑，还有一个Emacs模式被称为“JS2模式”标识功能无不良影响或回报值，它会赶上这些错误。\脚注{当然，如果你是一个Emacs的人。如果你喜欢{\它真正的编辑器（眨眼），我写了一个自定义JS荧光笔处理某些情况下比内建好：\ URL {http://github.com/spencertipping/js-vim-highlighter}}

###4.3	\第{{\ TT VAR}###
小心你如何定义一个变量。如果你离开了{\ TT VAR}关键字，您的变量将被定义在全球范围内，这可能会导致一些非常微妙的错误：
    VAR f =（）{/ / f是顶层，所以全球
        VAR x = 5; / / x是本地到f
        Y = 6; / / Y是全球性的
    };
据我所知，同样是真实的，在这两种类型| |循环：
    为（i = 0; I <10; + + I）/ /我是全球性的
    （VAR = 0;我<10; + + I）/ /我是本地的功能
    为（在some_object K）/ / K是全球性的
    （VAR在some_object K表）/ / K是本地的功能


###4.4 懒惰的范围和可变性###
这是一个美丽的灾难。检查了这一点：
    VAR X = [];
    （I = 0; I <3; + + I）
    X [I] =函数（）{;};

    X [0]（）/ /这是什么？
    X [1]（）;
    X [2]（）;

我们三个函数返回时，他们最终吗？你可能期望他们返回0，1和2，分别，因为这些都是值I当他们创建。但实际上，他们将返回3。这是因为JavaScript的懒惰的范围：创建后，每个函数接收只有一个变量的名称和范围，在其中搜索它本身的价值没有解决，直到调用时，在这一点我将等于3。
最简单的方法来解决这个问题，是我们的任务包在一个匿名函数，立即进行评估，引入另一层范围。下面的代码工作，因为在封闭的匿名函数，的价值| new_i |永远不会改变。
    （I = 0; I <3; + + I）
        （功能（new_i）{
            X [new_i] =函数（）{返回new_i;};
        }）（I）;
顺便说一下，你可能会做到这一点：
    （I = 0; I <3; + + I）{
        J = I;
        X [J] =函数（）{J;};
    }
这将不适用于同样的原因，我们原来的例子失败：| J |范围将最接近的封闭功能（记住，JavaScript的作用域是函数级别，不会阻止！水平），所以它的价值正在改变|我的一样频繁。

###4.5	\第{平等}###
因为| == |是跛脚的，这些都是在Javascript中的真实：
    空==未定义
    NULL == 0
    假的==''
    '' == 0
    真正的== 1
    真正的== '1'
    '1'== 1
因此，{\它从来没有使用{\ TT ==}操作，除非你真的想这种行为}。相反，使用| === |（其补！== |），其中表现理智。特别是，| === |需要两个操作数不仅是相同的十岁上下，但也有相同类型的。盒装的价值观和装箱值的结构比较的参照比较。如果一方盒装和其他拆箱，| === |将始终返回false。拆箱，因为字面字符串，不过，你可以使用它：|'富'==='FO'+'O'|。还有一种情况，特别是其中{\ TT ==}是多有用{\ TT ===。如果你想找出是否有一个属性表（即〜是不是{\ TT空}或{\ TT未定义}），去它的最简单的方法是{\ TT（X == NULL）}，而不是更明确的+（X ===空| | x ===未定义）。除了这个，我不能想象使用{\ TT ==}非常经常
     \注脚。事实上，有良好的安全性的理由不这样做，参见\ REF {秒。数字胁迫}}的所有细节

      bf的珍闻病理：原来不是甚至truthiness稳定。如果x = 0 和 TTŸ=新的号码（0）}，然后{\ TT x == Y}，{\ TT！X} {\ TT虚假}，
      {\ TT！Y} {\ TT真}。第\ REF {秒：拳击}谈到为什么这种事情发生。

###4.6	装箱与拆箱###
盒装值总是truthy可以存储性能。未装箱的值会默默不存储，例如：\脚注{有其他后果的拳击，见第文献\ {秒：小心与typeof运算}和\ REF {秒：小心与instanceof的}}的一些例子。
    VAR = 5;
    x.foo ='酒吧';
    x.foo / / =>未定义的x是一个装箱的数量。

    VAR x =新号码（5）;
    x.foo ='酒吧';
    x.foo / / =>'酒吧'，x是一个指针。
有时装箱的值如何获得一个盒子吗？当你做这些事情之一：
1.直接调用其构造，像上面我们
2.设置它的原型成员，并参阅|这|内该方法（见第\ REF {秒原型}）
3.的第一个参数传递函数的{\ TT通话}或{\ TT APPLY}方法（见节\ REF {秒：这是从来没有falsy}）
所有的HTML对象，不管他们是否是某种母语，将装箱。

###4.7	事情会默默地失败或胡作非为###
你可以逃脱，Javascript是非常宽松。尤其是下面的都是完全合法的：
    美孚/ / =>未定义[1，2，3]。
    [1，2，3] [4] / / =>未定义
    1/0 / / =>无限
    0 *'富'/ / =>南
这是非常有用的。几个常见的成语，像这些东西：
    e.nodeType | |（E =（e）条）;
    options.foo = options.foo | | 5;
此外，语言将转换{\什么}字符串或数字，如果你使用| + |所有这些表达式是字符串：
    NULL + [1，2] / / =>'null1，2'
    未定义+ [1，2] / / =>'undefined1，2'
    3 + {} / / => '3 [对象的对象]
    '+真/ / =>'真'
而这一切都是数字：
    未定义+未定义/ / =>南
    未定义+空/ / =>南
    空+空/ / => 0
    {} {} / / =>南
    真+真正/ / => 2
    0 +真/ / => 1
和一些我的最爱：
    空*假（真*假）（真*真）/ / => 1
    真正的<<真<<真/ / => 4
    真/空/ / =>无限
    [] == [] / / =>假
    [] == [] / / =>真

###4.8	数字胁迫###
这一个措手不及，我最近。 JavaScript的类型强制，有时有不一致的属性。例如：
    {} / / truthy
    ！{} / /要挟布尔，truthy
    + {} / /要挟数量，NaN的，这是falsy
    [] / / truthy，
    ！] / /为布尔要挟，truthy
    + [] / /要挟数，0，这是falsy

    [] == FALSE / /真（因为[]真的是零，或东西）
    [] == 0 / /真
    [] =='' / /真（因为0 ==''）
    [] == [] / /“假”（不同的引用，不强迫）
    [1] == [1] / /“假”（不同的参考，没有强制）
    [1] == + [1] / /真（右边是数量，胁迫）

你需要看像这样的事情，当你使用某些运营商与非数字的东西。例如，此功能不会告诉你一个数组是否包含任何truthy的值：

    has_truthy_stuff =功能（XS）{
        结果= 0;
        （VAR我= 0，L = xs.length; <L + + I）
        结果= XS [我];
        返回结果！
    };
    has_truthy_stuff（[{}，{}，0]）/ /返回false
| has_truthy_stuff |返回false的原因是因为当| {} |被裹挟到一个数字，就变成{\ TT NaN的}，这是在Javascript falsy。使用+ = + {\ TT NaN的}就像使用{\ TT 0};什么也没有发生。所以{\ TT结果} {\ TT 0}仍然阵列中的所有值，该函数将失败。
顺便说一下，你可以改变（重新）数字胁迫做什么定义{\ TT的valueOf方法：

    + {的valueOf（）{回报42}} / / - > 42
    Object.prototype.valueOf =函数（）{
        返回15;
    };
    Array.prototype.valueOf =函数（）{
        返回91;
    };
    + {} / / - > 15
    + [] / / - > 91
    [1] / / - > 91

这是关于这一点值得我们思考，因为它有一些有趣的影响。首先，{\ TT的valueOf（）}可能不会停止。例如：

    Object.prototype.valueOf =函数（）{
        而（真）;
    };
    {} == 5 / /从来没有回报; {}被强制到一个数字
    + {} / /永远不会返回
    ！{} / /返回false;绕过的valueOf（）

第二，{\ TT的valueOf}只是一个普通的Javascript功能，因此它可以创建安全漏洞。特别是，假设你使用{\ TT的eval（）}作为一个JSON解析器（不是一个好主意，方式），并没有检查输入格式良好的第一。如果有人向您发送| {的valueOf（）{（TRUE）;}} |，那么你的应用程序将挂起首次胁迫的对象一个数字（和这个强制可以是隐式的，像{\ TT == 5}情况以上）。
     {\ BF珍闻病理：}数组的数值取决于其内容：
     + [0] / / 0
     [1] / / 1
     [2] / / 2
     + [1] / / 1
     + [[[[[[[1]]]]]]] / / 1
     + [1，2] / /为NaN
     [真实] / /为NaN
     + ['4'] / / 4
     + [0 XFF'] / / 255
     + ['0xff的'] / / 255
     - [] / / 0
     - [1] / / -1
     - [1，2] / /为NaN
     如果您的阵列嵌套深度不够，内置数字阵列胁迫将无法与一个堆栈溢出错误。例如：
     VAR（X = [] = X，TMP，I = 0;我<100000; + +）{
        a.push（TMP = []）;
        = TMP;
     }
     a.push（42）/ /的价值，我们希望，100000级深
     x == 5 / /堆栈溢出在V8
     幸运的是，至少在V8，数字胁迫仍然是定义良好的，当你有一个数组，包含本身，所以这个例子是不是几乎一样多的乐趣，因为它可以：\脚注{虽然这可以很容易地改变，如果你重新定义{\ TT的valueOf（）}。}
     VAR = [];
     a.push（一）;
     + / / 0

###4.9	\第{大声会失败的事情}###
有一点Javascript将抱怨的地方。如果你调用一个非功能要求的属性| NULL |或未定义，或参考一个全局变量，不    存在，\要解决这种情况下的错误，你可以说{\ TT typeof运算符} {\ TT美孚}是可能不存在的全球的注脚。它会返回{\ TT'未定义'}{\ TT美孚}并没有被定义（或包含值{\ TT未定义}）}，然后Javascript将抛出一个|。TypeError异常|或| ReferenceError。推而广之，指局部变量不存在导致| ReferenceError，因为Javascript认为你所说的有关全局变量。

###4.10	抛出异常###
你可以在抛出很多不同的东西，包括装箱值。这可以有一定的优势;在此实例的代码：
    尝试{
        ...
        抛出3;
    }渔获量（N）{
        // n有没有堆栈跟踪！
    }

会抛出/ 捕捉不计算堆栈跟踪，使相当多的异常处理比平时快。但对于调试，这是更好地抛出一个适当的错误：
    尝试{
        ...
        引发新的错误（3）;
    }渔获量（E）{
        //é有一个堆栈跟踪在Firebug中，除其他事物的有用
    }

###4.11	 typeof运算要小心###
因为它的行为是这样的：
    typeof运算功能（）{} / / =>'功能'
    typeof运算[1，2，3] / / =>“对象”
    typeof运算{} / / =>“对象”
    typeof运算空/ / =>“对象”
    typeof运算typeof运算/ /挂起永远在Firefox
TT {typeof运算\}是一个真正跛脚的方法来检测的东西，在许多情况下。\脚注{因为它返回一个字符串，它是稍微慢比使用{\ TT。构造}}更好的是使用对象的|构造属性，像这样：

    （函数（）{}）。构造函数/ / =>功能
    [1，2，3]。构造函数/ / =>阵列
    （{}）。构造函数/ / =>对象
    true.constructor / / =>布尔
    null.constructor / / TypeError异常：空没有属性

为了抵御| NULL |和|未定义（既不让你问他们的构造），您可以尝试依靠这些价值观的虚假：
    x && x.constructor
但在实际上将失败|'' | | 0 |，|虚假|，|南，以及其他可能。我知道来解决这个问题的唯一途径，是刚刚做了比较：
    ===空| | X ===未定义？ X：x.constructor
    x ==空？ X：x.constructor / /同样的事情，但更简洁
另外，如果你只是想找到的东西是否是一个给定类型的，你可以使用| instanceof的，它永远不会抛出异常\脚注{嗯，差不多。如果你问 NULL}，未定义，或类似不适当的事情放在右侧，你会得到一个{\ TT TypeError异常}}

###4.12	也小心instanceof###
T的instanceof}一般比{\ TT typeof运算}更为有用，但它只有盒装值。例如，这些全是假的：
    3 instanceof的数
    '富'的instanceof弦乐
    真正的instanceof布尔

会然而，这些都是真实的：

    []数组的instanceof
    （{}）的instanceof对象
    继承自Object []的instanceof对象/ /阵列
    / foo /中的instanceof RegExp的/ /正则表达式总是盒装
    （函数（）{}）instanceof功能

的方式来解决的首要问题之一是包装原语：

    新号码（3）/ / TRUE的instanceof号
    新的String（'富'）的instanceof字符串/ /还不错
    新的布尔值（true）的instanceof布尔/ /还不错

在一般情况下，{\ TT（新x.constructor（X）的instanceof x.constructor）}将是真实的，所有的原始{\ TT X}。然而，这并不持有{\ TT空}或{\ TT未定义}。这些将抛出    错误，如果你问他们的构造，据我所知，从来没有从一个构造函数调用的结果返回（使用{\ TT新}，那就是）。

###4.13	浏览器不兼容###
一般来说，因为IE6的浏览器有良好的兼容性为核心语言的东西。然而，一个值得注意的例外是一个IE浏览器的错误，影响| String.split：

    VAR XS ='foo的酒吧BIF分裂（/（\ S +）/）;
    合理的浏览器XS / /：['富'，''，'酒吧'，'，'BIF]
    XS / /在IE浏览器：['富'，'酒吧'，'BIF]

一个更微妙的错误，我花了几个小时，发现是IE6也不会返回功能的eval（）|：

    VAR F =的eval（“（）{返回5}'）;
    F（）/ /合理的浏览器：5
    F（）/ /对IE6：“对象”（因为f是不确定的）

我敢肯定有其他类似的错误在那里，但最常见的导致的问题一般都是在DOM中。\脚注{jQuery的是你的朋友在这里。它作为一个Javascript品牌库，但实际上它是一个集增强的DOM（1）实现了统一的跨浏览器API，（2）更容易地获取和处理节点。}

5 原型(prototype)
-------------------------
  标签\ {秒：原型}
  我这里有一个非常反OOP的评论，但我考虑，我偶尔会使用原型删除它。尽管我对Javascript的语言明显，可能是不公平的仇杀
  妥协迎合Java灵感的营销压力，基于原型的编程\脚注{因此，它的名字，{\它的Java}脚本，尽管所有的异同。}有用的
  场合。本节包含我的主观和偏见。

  每当你定义一个函数，它有两个目的。它可以是每一个正常的程序员假定函数 - 也就是说，它可以采取的价值观和返回值，或者它可以是一个
  突变的实例产生的东西，它完全不同的东西。下面是一个例子：


/ /一个正常的功能：
VAR F =（X）返回X + 1};
F（5）/ / => 6


  这是大多数人的预期。这里的突变行为，没有理性的人会想象：


/ /构造函数
VAR f =函数（X）{this.x = X + 1} / /没有回报！
I = F（5）; / / IX = 6


  在这一点上是真正的下列事项：


i.constructor === f
i.__proto__ === i.constructor.prototype / / Firefox上，反正
我的instanceof f
typeof运算我===“对象”


  |新|关键字是右关联（前缀）一元运算符，所以你可以实例化一流的事情：


VAR = 5;
新x.constructor（）; / /创建一个x的盒装版本，不管X是什么
新的新功能（'X'，'this.x = 5'）;


  如果你要使用这个问题的设计模式编程，那么你可能会想的事情添加方法：\脚注说，本节{\ TT IX}将评估
  {\ TT 7}。虽然这不是真实的。它实际上是6所示。 （丹尼尔Gasparotto指出这一点。）}


VAR f =函数（X）{this.x = X};
f.prototype.add_one =函数（）{+ this.x};
I = F（5）;
i.add_one（）;
i.x / / => 6


  你可以找到这种原型编程在线信息吨。

###5.1	\第{为什么{\ TT新}是可怕}###
    {\ TT新}有一些很酷的功能（如第一级），但它有一个很可怕的缺点。在Javascript中的大部分功能，可以{\它转发} - 也就是说，你可以写一个新的
    函数来包装现有的功能被称为永远不会知道其中的差别。例如：


to_be_wrapped =功能（X）{X + 1};
包装=函数（）{
  返回to_be_wrapped.apply（这一点，参数）;
};
/ /对所有的x，包装（X）=== to_be_wrapped（X）


    然而，{\ TT新}有没有这样的机制。你不能转发构造在一般情况下，因为{\ TT新}相当于{\ TT APPLY}没有。 （虽然这不是整个故事;
    下一节一个辉煌的解决办法。）

###5.2	\第{为什么{\ TT新}是不那么可怕}###
    Ondrej扎拉我最近收到一封电子邮件，解释说，我对{\ TT新}偏见不攻自破，并含有抱怨的问题，我这是一个非常优雅的解决方法
    在上一节。这里是他的执行逐字：


VAR正向=函数（构造函数/ *参数* /）{
  VAR TMP =（）{};
  tmp.prototype = ctor.prototype;
  VAR INST =新的TMP（）;
  VAR ARGS = [];
  （VAR I = 1;我的arguments.length; +）{args.push（参数[I]）;}
  ctor.apply（INST里，args）;
  回到研究所;
}


    \ noindent，会用例：


类=（A，B，C）{}
VAR实例=（A类，A，B，C）;
实例instanceof类; / /真


    起初，我很怀疑，这种做法会工作，但我还没有找到它失败的情况下。这样的构造的确可以被转发在JavaScript中，尽管我以前的索赔
    与此相反。

###5.3	\第{为什么要使用原型}###
    如果你需要一个动态的调度模式，然后原型可能是你最好的赌注，你应该使用他们，而不是滚你自己的方法。谷歌的V8有一堆
    原型特定的优化，为以后做的Firefox版本。此外，原型节省内存;有一个指针的原型是比$ N $ $ N $属性的指针要便宜得多。

    如果，另一方面，你会发现自己实施的实际继承层次结构，那么你很可能犯了一个错误。\脚注{好吧，我被这一点偏颇。我倾向于治疗
    更像是计划比如Smalltalk中的JavaScript，所以我并不想太多经典的面向对象建模方面。此外，自闭包是真快，这是确定使用功能
    抽象，而不是继承。 JavaScript的往往是更适合比继承元编程}我已经找到原型是在JavaScript程序的有效途径，但
    在Javascript继承（1）慢，很慢，在某些情况下\脚注{。在Firefox 3.5之间的单层次和多层次的原型查找差异，例如，
    巨大的。}（2）不佳的JavaScript的``一切代表的是公众的“模型。

###5.4	\第{自动装箱}###
    标签\ {秒：自动装箱}
    你可能会尝试这样的事情：\脚注{{\ TT〜X}是一个成语，以确保{\ TT X}结束了作为一个布尔！。这是一个双重否定，{\ TT！}〜总是
    返回{\ TT TRUE}或{\ TT假}}


boolean.prototype.xor =（RHS）{回报！！ ！！ rhs}中;


    ，并运行此代码后，你会碰上这个惨遭不幸的财产：


false.xor（假）/ / =>真


    原因是，当你把一个未装箱的值作为一个对象（例如，调用它的方法之一），它就会被暂时晋升到该方法调用的目的装箱值。
    这并不改变它的值后，但它并不意味着它失去任何虚假的，它曾经有过。根据您正在使用的类型，你可以把它转换回一个未装箱的值：


功能（RHS）{回报！！ this.valueOf（）！==！ rhs}中;


6	\ {一个真正真棒平等}
-----------------------------

  标签\ {秒：一个真正的真棒平等}
  有关于JavaScript的真正重要的东西不是从它的使用方式是在所有显而易见的。它是这样的：语法| foo.bar的是，在所有情况下，相同
  |美孚['酒吧'] |。你可以安全地进行这种转变的时间提前到您的代码，无论是在价值属性，方法，或其他任何。通过扩展，可以指定非标识符
  对象属性的东西：


VAR FOO = [1，2，3];
为foo ['@潜泳！'] = 4;
为foo ['@潜泳！'] / / => 4


  您还可以读取属性这种方式，当然：


[1，2，3] ['长'] / / => 3
[1，2，3] ['推'] / / => [本地函数]


  事实上，这是什么|（VAR ...在...）|语法始建做：枚举对象的属性。因此，例如：


VAR属性= [];
（VAR K的文件）properties.push（K）;
属性/ / =>一大堆字符串


  然而，|为... |有黑暗的一面。它会做一些很奇怪的事情，当你开始修改原型。例如：


object.prototype.foo ='酒吧';
VAR属性= [];
（VAR K在{}）properties.push（K）;
属性/ / => ['foo'的]


  为了解决这个问题，你应该做两件事。首先，从来没有修改|对象|的原型，因为一切都是的一个实例对象（包括数组和所有其他盒装的东西）;
  第二，使用| hasOwnProperty：\脚注{确定，所以你可能想知道为什么我们没有看到{\ TT hasOwnProperty} {\ TT方法...在}循环，因为它显然是一个
  属性。其原因在于JavaScript的属性有无形的标志（如ECMAScript标准定义），其中被称为{\ TT DontEnum}的。如果{\ TT DontEnum}，设置一些
  属性，然后{\ TT ...在}循环将无法枚举它。 JavaScript没有提供一种方法来设置你添加到原型{\ TT DontEnum}的标志，因此，使用{\ TT
  hasOwnProperty}是一个很好的方法，以防止其他人的原型扩展循环。请注意，失败有时在IE6，我相信它始终返回false如果原型用品，
  名称相同的属性。


object.prototype.foo ='酒吧';
VAR属性= []，OBJ = {};
（VAR在obj K）obj.hasOwnProperty（K），&& properties.push（K）;
属性/ / => []


  而且非常重要的，从来没有使用| ...在遍历数组（它返回字符串的索引，而不是数字，这可能会导致问题）或字符串。这些要么会失败，如果你
  {\ TT阵列}或{\ TT字符串}（{\ TT对象}添加方法，但你不应该这样做）。

7	\ {如果你有20分钟...}
---------------------------------

  Javascript可以做几乎任何其他语言能做到。然而，它可能不是很明显该如何去。

7.1	\第{爽人的迭代}
    因为像Ruby语言向世界展示了如何通过\'E | |循环真的是，很多自我尊重功能的程序员不喜欢用它们。如果你在Firefox中，你
    不会有阵列原型包括|地图|和|的forEach |功能已经。但如果你正在编写跨浏览器的代码，并没有使用一个库，为他们提供
    为你，这里是一个很好的方式来实现：


array.prototype.each = Array.prototype.forEach | |函数（F）{
  （VAR我= 0，L = this.length; <L + + I）
    F（[I]）;
  返回的链接/ /方便
};

array.prototype.map = Array.prototype.map | |函数（F）{
  VAR YS = [];
  （VAR我= 0，L = this.length; <L + + I）
    ys.push（f（本[我]））;
  返回YS;
};


    据我所知，这是（几乎）以最快的方式来写这些功能。我们声明两个变量前（|我|和| L |），这样的长度是缓存; Javascript将不知道
    this.length是不变与| |循环，所以它会检查每一个时间，如果我们不能缓存。这是昂贵的，因为由于拳击，我们就会有一个失败的哈希查找
    |这|，然后下降到this.__proto__ |，会发现它的特殊属性的长度。然后，方法调用会发生检索
    |长度|。\脚注{得到的Javascript如何呈现某些API。它内部有一个gettable和设置属性的概念，虽然没有一个跨浏览器的方法
    创建它们。但属性，如{\ TT长度} {\ TT的ChildNodes}等〜是所有真正的方法调用，而不是实地查找。 （尝试分配到一个，你会看到。）}

    只有进一步优化，可以通过阵列向后（只|每|，因为|地图|假设维持秩序）：


array.prototype.each =功能（F）{
  （I = this.length - 1> = 0; - 我）
    F（[I]）;
};


    这结束是非常略高于第一实现更快，因为它改变了一个浮点减法（需要评估\ | <|为非零数量）成一个符号动词
    检查，它的内部是按位|和|和零谓跳。除非你的JavaScript引擎，内联函数，你真的有决心，有杀手的性能（在
    这点，我会问你为什么摆在首位的Javascript），你可能永远需要考虑的一个非零相对开销| <|和〜零|> = |。

    您还可以定义一个迭代器对象，但不是这个样子：


/ /没有！！不这样做！
object.prototype.each =功能（F）{
  （VAR在此K）this.hasOwnProperty（K）&& F（K）;
};


    更好的是要实现一个单独的|键|功能，以避免污染|对象|原型：


VAR键=功能（O）{
  XS = [];
  （VAR在O K）o.hasOwnProperty（K），&& xs.push（K）;
  返回XS;
};


7.2	\第{Java类和接口}
    任何理智的人任何时候都希望使用这些。但是，如果你是疯了或正在被迫，那么谷歌Web工具包会给你一种方式来拍摄自己的脚，把它变成
    中的JavaScript。

7.3	\第{递归元类}
    有不同的方法来实现这一点，但一个简单的方法是这样做的：\脚注{请记住，一类是只是一个函数，它产生的实例。一无所知
    {\ TT新的关键字是必要的，写面向对象的代码（谢天谢地）。}


元类= {方法：{
  add_to功能：（O）{
    T =;
    键（this.methods）（函数（k）{
      问题o [K] = BIND（t.methods [K]，O）; / /不能使用/ /这里
    }）;
    返回O}};
metaclass.methods.add_to.call（元类，元类）;


    在这一点上，|元类本身现在是|元类。我们就可以开始执行它的实例：


VAR regular_class = metaclass.add_to（{方法：{}}）;
regular_class.methods.def =功能（名称，值）{
  this.methods [名称] =值;
  返回本;
};
regular_class.methods.init =函数（O）{
  实例= O | | {方法：{}};
  this.methods.init && this.methods.init.call（实例）;
  返回this.add_to（实例）;
};
regular_class.add_to（regular_class）;


    这是一个Ruby风格的类，在这里你可以定义公共方法和构造。因此，例如：


点= regular_class.init（）;
point.def（'初始化'，函数（）{this.x = this.y = 0}）;
point.def（“距离”，函数（）{
  返回Math.sqrt（this.x * this.x + this.y * this.y）}）;


    我们使用的是相当冗长| this.x |，这可能会得罪一些Python-避开的Ruby爱好者。幸运的是，我们可以使用动态重写使用| $ |地方Ruby爱好者将使用
    | @ |：{。，事实上，我们可以烤成一个元类，使其完全透明的，如果我们想{\ TT改造红宝石（）}} \脚注


VAR红宝石=功能（F）{
  返回的eval（f.toString（）（/ \ $（\ W +）/克，
    函数（，名称）{返回'。“ +名称}））;
};

point.def（“初始化”，红宝石（函数（）{$ X = $ Y = 0}））;
point.def（“距离”，红宝石（函数（）{
  返回Math.sqrt（$ X * $ x + $ Y * $ Y）}））;


    现在你可以使用这个类：


P = point.init（）;
p.x = 3，p.y = 4;
p.distance（）/ / => 5


    使用元类的优点是，你可以做有趣的东西，它们的结构。例如，假设我们要插入到我们的所有点的调试方法跟踪
    用途：\脚注{这里的例子使用含有{\ TT arguments.join}，表达，这是无效的 - {\ TT参数}是不是一个数组。现在，它使用的``假装这是一个数组
    上调用{\ TT连接}“的成语，通常的目的。 （虽然你有时不是广义方法的错误，是对浏览器的情况下，如果您尝试使用
    {\，TT Array.prototype.toString（）}这种方式。）}


键（point.methods）（函数（k）{
  VAR原point.methods [K];
  point.methods [K] =函数（）{
    跟踪（“调用方法”+ K +'参数'+
           array.prototype.join.call（参数，'，'））;
    返回original.apply（这一点，参数）;
  };
}）;


    |跟踪|（这是不是内置的，所以你必须定义一个Javascript）被称为每次任何方法|点|实例被称为，这将有机会获得
    双方的观点和国家。

7.4	\第{尾调用}
    JavaScript并没有做尾部调用优化默认情况下，这是一种耻辱，因为有些浏览器调用栈短（最短的，我所知道的是500帧，由特别
    很快，当你有绑定功能和迭代）。幸运的是，在Javascript编码尾调用，实际上是非常简单的：


function.prototype.tail =函数（）{[这一点，参数]};
function.prototype.call_with_tco =函数（）{
  VARç= [这一点，参数;
  逃生=参数的arguments.length - 1];
  （C [0] ==逃生）
    C = C [0]申请（本，C [1]）;
  escape.apply返回（这一点，C [1]）;
};


    现在我们可以用这个定义来写尾部调用优化的阶乘函数：\脚注{这种技术被称为{\ EM蹦床}，并不构成实施分隔
    延续，后来我发现。然而，它还是蛮爽的。}


/ /标准的递归定义
fact1 =功能（N）{
  返回N> 0？ N * fact1（N - 1）：1;
};

/ /尾递归定义
fact2 =功能（ACC）{
  返回N> 0？ fact2（N - 1，ACC * N）：ACC;
};

/ /我们的尾部调用机制
fact3 =功能（N，K），ACC {
  返回N> 0？ fact3.tail（N - 1，ACC * N，K）：k.tail（ACC）;
};


    前两个函数通常可以被称为：


fact1（5）/ / => 120
fact2（5，1）/ / => 120


    \ noindent，会，但双方将在不断的堆栈空间运行。第三，另一方面，如果我们把它这种方式：


ID =函数（X）{X};
fact3.call_with_tco（5，1，ID）/ / => 120


    尾部调用优化策略的工作方式，而不是创建新的堆栈帧：


fact1（5）
  5 * fact1（4）
    4 * fact1（3）
    ...


    \ noindent，会甚至创造空心的：


fact2（5，1）
  fact2（4，5）
    fact2（3 20）
    ...


    \ noindent，会弹出最后的堆栈帧分配一个新的（处理阵列之前[功能中，args] |要返回的延续）：


fact3（5，1，K） - > [fact3，[4，5，K]
fact3（4，5，K） - > [fact3，[3，20，K]
fact3（3，20，K）...


    这不是一个糟糕的表现命中， - 两个元素的数组的指针分配的开销是最小的。

7.5	\第{的句法宏和操作符重载}
    懒惰的范围，让我们做一些很酷的东西。比方说，我们要定义一个新的变量声明的语法形式，代替：


VAR =函数（）{
  Y =（（X）返回X + 1}）（5）;
  ...
};


    \ noindent，会我们可以写：


VAR =函数（）{
  Y =（X + 1）（X = 5）;
  ...
};


    这可以在正则表达式实现，如果我们不介意，大约一半的时间远远不正确：


expand_where =功能（F）{
  VAR = f.toString（）;
  返回的eval（s.replace（/ \（（[^）]）\）\（（[^）]）\）/ \。，
    函数（，身体，值）{
      返回'（功能（“+ value.split（'='）[0 +'）{回报'+
             机身+'}）（“+ value.split（'='，2）[1] +”）“;
    }））;
};


    现在，我们可以这样说：


VAR = expand_where（的函数（）{
  Y =（X + 1）（X = 5）;
  ...
}）;


    显然是一个适当的解析器是比较合适的，因为它不会失败简单括号边界的。但重要的是实现一个函数给你一个引用代码的方式，只是
    喜欢在Lisp：


（defmacro美孚（栏）...）
（foo的一些表达）


    \ noindent，会成为在Javascript（假设存在|解析|和| deparse |，这是相当复杂）：\脚注{这些真实的版本中实现的
    \ URL {http://github.com/spencertipping/caterwaul}的，如果你有兴趣，看到他们的样子。这也是合理的句法边缘案件参考。


VAR defmacro =（变换）{
  返回功能（F）{
    返回的EVAL（deparse的（转换（解析（f.toString（）））））;
  };
};
VAR FOO = defmacro（功能（parse_tree）{
  回归......;
}）;
美孚（函数（）{一些表达式}）;


    这个原则可以扩展到允许操作符重载，如果我们写改写成方法调用运营商的转型：


X << Y / /变为x [“<<”]（Y）


    请记住，属性名不限制标识符 - 所以我们可以重载| <<阵列工作，就像它在Ruby中没有与运营商：


array.prototype ['<<'] =函数（）{
  （VAR我= 0，L =的arguments.length; <L + + I）
    this.push（参数[I]）;
  返回本;
};


    这是关于实施这种东西在Javascript中，而比Lisp不幸的是唯一的Javascript烤成语法的语法结构，所以试图引进新的
    句法形式，如| |时，是不是很方便：


expand_when（函数（）{
  当（富）{/ /编译错误; {意外
    酒吧（）;
  }
}）;


    但是，什么可以做，里面的Javascript解析树是公平的游戏。\脚注{记住{\ TT的toString}有时会重写你的函数的标准形式，所以利用
    含糊不清的语法是无益的。例如，在Firefox中，写多余的括号表达式是没有用的，因为这些多余的括号丢失，当你调用{\ TT
    的toString}}

8	\ {进一步阅读}
----------------------------
  我强烈建议阅读（\ URL {http://jquery.com}）jQuery的代码库的质量和自觉性。这是一个辉煌的一块工作，我学到了大量
  通过它刨着左右。

  道格拉斯，克罗克福德已书面包括知名{\它的JavaScript：好的零件}一些优秀的Javascript引用，语言和一个不太知名的，但免费在线旅游
  \网址{http://javascript.crockford.com/survey.html}的\脚注{他JavaScript和矿山之间有一些差异。既不是不正确的，只是不同的不成文
  假设。例如，当他说，有三个原始，他是正确的，他计数装箱交涉，而我算他们的文字数量
  构造。}

  作为一个无耻的插件，我也建议通过三岔口（\ URL {http://github.com/spencertipping/divergence}），我写了一个库，阅读。这是非常不同 - 从jQuery更
  简洁和算法（并没有DOM参与）。 jQuery使用更传统的方法，而分歧往往使倒闭的大量使用和功能的元编程。

  如果你的Lisp和元编程，你也可能享受\ URL {http://github.com/spencertipping/divergence.rebase}和\ URL {http://github.com/spencertipping/caterwaul}的两个项目
  使用功能系列化和的eval（）|实施一些在最后一节中提到的语法扩展。

  另外，我最近发现称为\ URL {http://wtfjs.com}网站，这似乎是致力于揭露所有JavaScript的边缘的情况下病症。这是相当有趣，启发读。更
  深入看看JavaScript的好，坏，丑陋的部分是\网址{http://perfectionkills.com}的;本网站书面的PrototypeJS开发商之一，已经说服了我，我真的
  不知道的Javascript。
\ {文件}

